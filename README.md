markdown
# Циклические алгоритмы: решение задач на Python

Этот репозиторий содержит реализации пяти циклических алгоритмов для решения различных математических и алгоритмических задач.

## Содержание

1. [Нахождение корня уравнения](#1-нахождение-корня-уравнения)
2. [Вычисление площади под графиком функции](#2-вычисление-площади-под-графиком-функции)
3. [Вычисление площади многоугольника](#3-вычисление-площади-многоугольника)
4. [Решение уравнения генетическим алгоритмом](#4-решение-уравнения-генетическим-алгоритмом)
5. [Поиск кратчайшего пути в лабиринте](#5-поиск-кратчайшего-пути-в-лабиринте)

---

## 1. Нахождение корня уравнения

**Метод**: Биссекции (деление отрезка пополам)

**Функция**: `find_root_bisection(f, a, b, epsilon=1e-6)`

**Параметры**:
- `f` - функция, корень которой ищем
- `a`, `b` - границы интервала
- `epsilon` - точность

**Пример использования**:
```python
def example_function(x):
    return x**3 - 2*x - 5

root = find_root_bisection(example_function, 2, 3)


---

## 2. Вычисление площади под графиком функции

**Метод**: Трапеций

**Функция**: `calculate_area_trapezoid(f, a, b, n=1000)`

**Параметры**:
- `f` - интегрируемая функция
- `a`, `b` - границы интегрирования
- `n` - количество интервалов разбиения

**Пример использования**:
```python
import math
area = calculate_area_trapezoid(math.sin, 0, math.pi)
```

---

## 3. Вычисление площади многоугольника

**Метод**: Монте-Карло

**Функция**: `polygon_area_monte_carlo(vertices, num_points=100000)`

**Параметры**:
- `vertices` - список вершин многоугольника
- `num_points` - количество случайных точек

**Пример использования**:
```python
vertices = [(0, 0), (2, 0), (2, 2), (1, 3), (0, 2)]
area = polygon_area_monte_carlo(vertices)
```

---

## 4. Решение уравнения генетическим алгоритмом

**Функция**: `genetic_algorithm_solver(f, target, bounds, pop_size=100, generations=100, mutation_rate=0.1)`

**Параметры**:
- `f` - функция для решения
- `target` - целевое значение
- `bounds` - границы для переменных
- `pop_size` - размер популяции
- `generations` - количество поколений
- `mutation_rate` - вероятность мутации

**Пример использования**:
```python
def example_equation(x1, x2, x3, x4):
    return x1**2 + x2**2 + x3**2 + x4**2

solution = genetic_algorithm_solver(example_equation, 10, [(-5, 5)]*4)
```

---

## 5. Поиск кратчайшего пути в лабиринте

**Метод**: BFS (поиск в ширину)

**Функция**: `find_shortest_path(maze)`

**Параметры**:
- `maze` - матрица лабиринта

**Возвращает**:
- Длину пути
- Список координат пути

**Пример использования**:
```python
maze = [
    ['C', '0', '0', '0', '0', 'X', '0', '0'],
    # ... остальные строки лабиринта
    ['X', '0', '0', '0', 'X', '0', '0', 'B']
]

length, path = find_shortest_path(maze)
```

---

## Требования

- Python 3.6+
- Стандартные библиотеки Python (math, random, collections)

## Установка

1. Клонируйте репозиторий:
```bash
git clone https://github.com/ваш-username/циклические-алгоритмы.git
```

2. Перейдите в директорию проекта:
```bash
cd циклические-алгоритмы
```

3. Запустите нужный скрипт:
```bash
python название_скрипта.py
```

## Лицензия

Этот проект распространяется под лицензией MIT.
